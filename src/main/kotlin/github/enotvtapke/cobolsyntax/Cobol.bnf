{
  parserClass="github.enotvtapke.cobolsyntax.psi.parser.CobolParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Cobol"
  psiImplClassSuffix="Impl"
  psiPackage="github.enotvtapke.cobolsyntax.psi"
  psiImplPackage="github.enotvtapke.cobolsyntax.psi.impl"

  elementTypeHolderClass="github.enotvtapke.cobolsyntax.psi.CobolTypes"
  elementTypeClass="github.enotvtapke.cobolsyntax.psi.CobolElementType"
  tokenTypeClass="github.enotvtapke.cobolsyntax.psi.CobolTokenType"

  tokens = [
    LPAREN = "("
    RPAREN = ")"
    COMMENT = "COMMENT"
    POWER = "**"
    PLUS = "+"
    MINUS = "-"
    STAR = "*"
    SLASH = "/"
    GE = ">="
    LE = "<="
    NE = "<>"
    GT = ">"
    LT = "<"
  ]
}

cobolFile ::= identificationDivision dataDivision? procedureDivision?

identificationDivision ::= IDENTIFICATION DIVISION DOT programIdParagraph
programIdParagraph ::= PROGRAM_ID DOT IDENTIFIER DOT

dataDivision ::= DATA DIVISION DOT workingStorageSection?
workingStorageSection ::= WORKING_STORAGE SECTION DOT dataItemDefinition*

dataItemDefinition ::= levelNumber dataName pictureClause valueClause? DOT
levelNumber ::= INTEGER
dataName ::= IDENTIFIER
pictureClause ::= PIC IS? PICTURE_STRING
valueClause ::= VALUE literal
literal ::= INTEGER | STRING

procedureDivision ::= PROCEDURE DIVISION DOT paragraph*
paragraph ::= paragraphName DOT statement*
paragraphName ::= IDENTIFIER

statement ::= performStatement | stopStatement | displayStatement | computeStatement | addStatement | subtractStatement | multiplyStatement | divideStatement | moveStatement | acceptStatement | ifStatement

performStatement ::= PERFORM IDENTIFIER varyingClause? DOT?
varyingClause ::= VARYING IDENTIFIER FROM (IDENTIFIER | literal) BY (IDENTIFIER | literal) UNTIL condition

ifStatement ::= IF condition statement* elseClause? END_IF DOT?
elseClause ::= ELSE statement*

condition ::= andCondition (OR andCondition)*
andCondition ::= notCondition (AND notCondition)*
notCondition ::= NOT? relationCondition
relationCondition ::= arithmeticExpression relationalOperator arithmeticExpression
relationalOperator ::= EQ | GT | LT | GE | LE | NE

stopStatement ::= STOP RUN DOT

displayStatement ::= DISPLAY (IDENTIFIER | literal)+ DOT

computeStatement ::= COMPUTE IDENTIFIER EQ arithmeticExpression DOT

addStatement ::= ADD arithmeticOperand TO IDENTIFIER givingClause? DOT
subtractStatement ::= SUBTRACT arithmeticOperand FROM IDENTIFIER givingClause? DOT
multiplyStatement ::= MULTIPLY arithmeticOperand BY IDENTIFIER givingClause? DOT
divideStatement ::= DIVIDE arithmeticOperand BY arithmeticOperand givingClause? DOT

arithmeticOperand ::= INTEGER | IDENTIFIER
givingClause ::= GIVING IDENTIFIER

moveStatement ::= MOVE (IDENTIFIER | literal) TO IDENTIFIER DOT
acceptStatement ::= ACCEPT IDENTIFIER DOT

arithmeticExpression ::= additiveExpression

additiveExpression ::= multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)*

multiplicativeExpression ::= powerExpression ((STAR | SLASH) powerExpression)*

powerExpression ::= unaryExpression (POWER unaryExpression)*

unaryExpression ::= (PLUS | MINUS)? primaryExpression

primaryExpression ::= INTEGER | IDENTIFIER | LPAREN arithmeticExpression RPAREN
