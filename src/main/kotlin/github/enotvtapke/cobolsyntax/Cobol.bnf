{
  parserClass="github.enotvtapke.cobolsyntax.psi.parser.CobolParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Cobol"
  psiImplClassSuffix="Impl"
  psiPackage="github.enotvtapke.cobolsyntax.psi"
  psiImplPackage="github.enotvtapke.cobolsyntax.psi.impl"

  elementTypeHolderClass="github.enotvtapke.cobolsyntax.psi.CobolTypes"
  elementTypeClass="github.enotvtapke.cobolsyntax.psi.CobolElementType"
  tokenTypeClass="github.enotvtapke.cobolsyntax.psi.CobolTokenType"

  tokens = [
    LPAREN = "("
    RPAREN = ")"
    COMMENT = "COMMENT"
    POWER = "**"
    PLUS = "+"
    MINUS = "-"
    STAR = "*"
    SLASH = "/"
    GE = ">="
    LE = "<="
    NE = "<>"
    GT = ">"
    LT = "<"
  ]
}

cobolFile ::= identificationDivision dataDivision? procedureDivision?

identificationDivision ::= IDENTIFICATION DIVISION DOT programIdParagraph
programIdParagraph ::= PROGRAM_ID DOT IDENTIFIER DOT

dataDivision ::= DATA DIVISION DOT workingStorageSection?
workingStorageSection ::= WORKING_STORAGE SECTION DOT dataItemDefinition*

dataItemDefinition ::= levelNumber dataName pictureClause valueClause? DOT
levelNumber ::= INTEGER
dataName ::= IDENTIFIER
pictureClause ::= PIC IS? PICTURE_STRING
valueClause ::= VALUE literal
literal ::= INTEGER | STRING

procedureDivision ::= PROCEDURE DIVISION DOT sentence* paragraph*
paragraph ::= paragraphName DOT sentence*
sentence ::= statement* DOT
paragraphName ::= IDENTIFIER

statement ::= performStatement | stopStatement | displayStatement | computeStatement | addStatement | subtractStatement | multiplyStatement | divideStatement | moveStatement | acceptStatement | ifStatement

performStatement ::= performOutOfLine | performInline
performOutOfLine ::= PERFORM IDENTIFIER thruClause? (varyingClause | untilClause)?
performInline ::= PERFORM (varyingClause | untilClause)? statement* END_PERFORM
thruClause ::= THRU IDENTIFIER
varyingClause ::= VARYING IDENTIFIER FROM (IDENTIFIER | literal) BY (IDENTIFIER | literal) UNTIL condition
untilClause ::= UNTIL condition

ifStatement ::= IF condition THEN statement* elseClause? END_IF
elseClause ::= ELSE statement*

condition ::= andCondition (OR andCondition)*
andCondition ::= notCondition (AND notCondition)*
notCondition ::= NOT? relationCondition
relationCondition ::= arithmeticExpression relationalOperator arithmeticExpression
relationalOperator ::= EQ | GT | LT | GE | LE | NE

stopStatement ::= STOP RUN

displayStatement ::= DISPLAY (IDENTIFIER | literal)+

computeStatement ::= COMPUTE IDENTIFIER EQ arithmeticExpression

addStatement ::= ADD arithmeticOperand TO IDENTIFIER givingClause?
subtractStatement ::= SUBTRACT arithmeticOperand FROM IDENTIFIER givingClause?
multiplyStatement ::= MULTIPLY arithmeticOperand BY IDENTIFIER givingClause?
divideStatement ::= DIVIDE arithmeticOperand BY arithmeticOperand givingClause?

arithmeticOperand ::= INTEGER | IDENTIFIER
givingClause ::= GIVING IDENTIFIER

moveStatement ::= MOVE (IDENTIFIER | literal) TO IDENTIFIER
acceptStatement ::= ACCEPT IDENTIFIER

arithmeticExpression ::= additiveExpression

additiveExpression ::= multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)*

multiplicativeExpression ::= powerExpression ((STAR | SLASH) powerExpression)*

powerExpression ::= unaryExpression (POWER unaryExpression)*

unaryExpression ::= (PLUS | MINUS)? primaryExpression

primaryExpression ::= INTEGER | IDENTIFIER | LPAREN arithmeticExpression RPAREN
